import numpy as np

# евклидово расстояние между двумя точками
def dist(A, B):
    # TODO: реализуйте вычисление евклидова расстояния для двух точек A и B в N-мерном пространстве
    # Помните, что размерность пространства может быть произвольной (не только 2D).
    # Для взятия разностей по каждому измерерию можно использовать код: A - B
    # Для возведения в квадрат можете использовать оператор ** (например, 3**2 == 9) или функцию np.power
    # Для вычисления суммы используйте функцию sum или np.sum
    # Для вычисления квадратного корня используйте функцию np.sqrt
  r = np.sqrt(np.sum((A-B)**2))
  return r


# возвращает список индексов ближайших центров по каждой точке
def class_of_each_point(X, centers):
  m = len(X)
  k = len(centers)

  # матрица расстояний от каждой точки до каждого центра
  distances = np.zeros((m, k))
  for i in range(m):
    for j in range(k):
      distances[i, j] = dist(centers[j], X[i])

  # поиск ближайшего центра для каждой точки
  return np.argmin(distances, axis=1)


def kmeans(k, X):

    # numpy.shape(a), где a - массив, возвращает длину массива по каждой оси в виде кортежа
    # [0] - количество строк в матрице Х - показывают количество студентов
    # [1] - количество столбцов в матрице Х - показывают количество признаков
    m = np.shape(X)[0]
    n = np.shape(X)[1]

    curr_iteration = prev_iteration = np.zeros(m)
    # Заполнение массива предыдущей итерации матрицей, состоящей из нулей

    # TODO: сгенерировать k кластерных центров со случайными координатами.
    # Должна получиться матрица случайных чисел размера k*n (k строк, n столбцов).
    # по формуле (b - a) * np.random.random() + а, где b > a
    # мы меняем диапазон на [a, b]
    centers = np.random.random((k, n)) * (np.max(X, axis=0) - np.min(X, axis=0)) + np.min(X, axis=0)

    # приписываем каждую точку к заданному классу
    curr_iteration = class_of_each_point(X, centers)

    # цикл до тех пор, пока центры не стабилизируются
    #   np.any(a1 != a2)
    # проверяет, что существует такой элемент в массиве а1, не равный элементу в массиве а2
    # при этом у этих элементов одинаковый индекс, если это так, то вернёт True
    while np.any(prev_iteration != curr_iteration):

      prev_iteration = curr_iteration

      # вычисляем новые центры масс
      for i in range(k):
        sub_X = X[curr_iteration == i,:]
        if len(sub_X) > 0:
          centers[i,:] = np.mean(sub_X, axis=0)

      # приписываем каждую точку к заданному классу
      curr_iteration = class_of_each_point(X, centers)

    return centers
